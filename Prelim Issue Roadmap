1. Core spec & schema
Issue 1 — Refine GenGraph v0.1 core entity model

Title: Refine GenGraph v0.1 core entity model (persons, events, places, sources, properties, titles)

Body:

The current SPEC.md defines six core entities::

Person

Event

Place

Source

Property

Title

This issue is for discussion and refinement of that core set:

Are these the right “atoms”?

Are we missing any obvious entity types for v0.1?

Are any of these too granular / not granular enough?

Are there fields that should be required vs optional?

Please comment with:

Real-world examples where this model works well

Real-world examples where this model breaks down

Concrete proposed changes to SPEC.md

Goal: converge on a slightly more battle-tested v0.1 entity set before considering v0.2.

Issue 2 — Introduce a first-class Claim / Assertion object?

Title: Consider first-class Claim / Assertion objects for evidence-heavy use cases

Body:

Right now, evidence/provenance lives mostly on:

Event.sourceIds

Relation.sourceIds

This keeps v0.1 simple, but may be too limited for:

Contradictory evidence

Complex reasoning chains

“Soft” claims like hypotheses and research notes

Proposal to discuss: introduce a first-class Claim/Assertion entity, e.g.:

{
  "id": "C1",
  "subjectId": "P1",
  "predicate": "bornIn",
  "objectId": "PL1",
  "dateRange": { "earliest": "1759-01-01", "latest": "1761-12-31" },
  "sourceIds": ["S1", "S2"],
  "confidence": 0.7,
  "note": "Census + baptism; dates approximate."
}


Questions:

Is this worth the extra complexity for v0.1/v0.2?

Would a Claim layer replace some Relations, or sit beside them?

Can we keep a “simple mode” and an “advanced mode”?

Looking for feedback from genealogists, archivists, and graph/ontology folks.

Issue 3 — Improve date handling (uncertainty, ranges, partial dates)

Title: Improve date representation (uncertain dates, ranges, partial dates)

Body:

v0.1 supports:

date: free-form string

dateRange: { earliest, latest } strings

We should discuss:

Recommended formats (ISO-like? GEDCOM-style date parsing?)

How to encode partial dates (month/year, year only)

Uncertain dates (e.g. “before 1750”, “after 1790”)

Whether date should be constrained more tightly for interoperability

Deliverables:

Updated guidance in SPEC.md

Maybe an optional “date encoding profile” or examples section.

Issue 4 — Relation types: recommended vocabulary & best practices

Title: Define recommended relation types and best practices for relations[]

Body:

Current spec suggests (but does not enforce) relation types like:

PARENT_OF, CHILD_OF, SPOUSE_OF, SIBLING_OF

PARTICIPANT_IN, OCCURRED_AT

OWNED_PROPERTY, INHERITED_PROPERTY, HELD_TITLE

CONFLICTS_WITH, ALTERNATIVE_TO

This issue is to:

Propose a recommended core vocabulary of relation types

Clarify directionality (e.g. we store PARENT_OF but not CHILD_OF, or both?)

Decide how strict v0.1 should be (free-text vs controlled vocabulary)

Goal: document a “recommended core relations table” in SPEC.md without over-constraining experimentation.

2. JSON Schema & validation
Issue 5 — Add JSON Schema validation helper (Python)

Title: Add optional JSON Schema validation helper in Python

Body:

We already have schema/gengraph.schema.json for v0.1.

This issue is to:

Add an optional Python-based validator (e.g. using jsonschema)

Wire a small validate_gengraph.py script or function

Document how to run validation on a file

Constraints:

Keep core dependencies minimal (maybe put jsonschema in an [extra] group or separate script).

Nice to have:

Pre-commit hook example for validating .gengraph.json files.

Issue 6 — Expand schema with richer examples & comments

Title: Expand JSON Schema with richer examples and description fields

Body:

The current JSON Schema is minimal and mostly structural.

Improvements to consider:

Add "description" metadata for each definition (person, event, place, etc.)

Add "examples" where helpful

Clarify which fields are recommended vs truly optional

This will help tooling, documentation generators, and new contributors.

3. Tooling & code
Issue 7 — Implement basic in-memory graph view

Title: Implement a basic in-memory graph view (nodes + adjacency)

Body:

Right now, gengraph/io.py just loads JSON and prints counts.

This issue proposes adding a minimal graph view:

Build adjacency mappings for relations[]

Helper functions like:

get_person(data, id)

get_relations_for(id)

get_spouses(personId)

get_children(personId)

Keep it simple and in-memory: no DB / external deps yet.

Goal: make it easy for others to experiment with GenGraph in Python notebooks / scripts.

Issue 8 — Add command-line tool to inspect and query a GenGraph file

Title: Add CLI commands to inspect/query a GenGraph file

Body:

Extend the existing python -m gengraph behavior to support subcommands, e.g.:

gengraph summary <file> – current summary output

gengraph list-persons <file> – IDs and names

gengraph show-person <file> <personId> – detail view

Stretch goals:

gengraph neighbors <file> <entityId> – show directly connected relations

This would:

Demonstrate usage of the format

Give people something tangible to play with quickly.

Issue 9 — Outline GEDCOM → GenGraph converter

Title: Design outline for GEDCOM → GenGraph converter

Body:

A key promise of GenGraph is: “Import from GEDCOM, add richness.”

This issue is about design, not full implementation:

Document a mapping from common GEDCOM tags to GenGraph structures

Identify ambiguous / lossy mappings

Decide which GEDCOM fields we will:

map directly

stash in note fields

ignore (for now)

Deliverable:

A new doc (e.g. GEDCOM_MAPPING.md) with a first-pass mapping table.

Future work: separate issue for an actual converter script.

4. Examples & documentation
Issue 10 — Add more realistic example datasets

Title: Add more realistic GenGraph example files

Body:

The repo currently has only minimal_example.gengraph.json.

It would be helpful to add:

A “medium complexity” example:

10–20 persons

Several events, places, and sources

At least one property and one title

Some conflicting or low-confidence relations

Possibly an anonymised or fictional dataset that shows:

Migration

Multi-generational relationships

Different evidence strengths

These examples will be crucial for:

Testing

Onboarding new contributors

Evaluating schema changes.

Issue 11 — Improve README with diagrams and narrative use-cases

Title: Improve README with diagrams and example use-cases

Body:

The current README.md explains the idea but could be more visual and narrative.

Proposed improvements:

Add 1–2 simple diagrams (e.g. person–event–place graph)

Describe 2–3 concrete workflows:

A genealogist using GenGraph to represent complex evidence

An archivist mapping collections and people

A developer building a graph-based visualization or query engine

Goal: make it immediately obvious to newcomers what GenGraph is for and why it’s interesting.

Issue 12 — Add FAQ section (format vs. product; open-source vs. commercial use)

Title: Add FAQ explaining scope, philosophy, and potential use cases

Body:

Many people may ask:

Is GenGraph meant to replace GEDCOM?

Is this “just a file format” or a product?

Can I use this commercially?

How does this relate to standards like CIDOC-CRM, GEDCOM X, etc.?

We should add an FAQ section to the README (or a separate FAQ.md) that addresses:

Scope of the project (spec + reference tools)

Intended interoperability with existing standards

License and commercial usage expectations

How people can safely experiment or integrate this in their own projects.

5. Ecosystem & alignment
Issue 13 — Survey related standards (CIDOC-CRM, GEDCOM X, JSON-LD, etc.)

Title: Survey and document related standards (CIDOC-CRM, GEDCOM X, JSON-LD, etc.)

Body:

Before GenGraph evolves too far, we should look sideways at:

CIDOC-CRM / CRM extensions

GEDCOM X

GEDCOM 7 (and tooling around it)

JSON-LD / RDF vocabularies used in cultural heritage

Task:

Collect links, short summaries, and key insights from existing work

Add a section to SPEC.md or a new RELATED_WORK.md

Goal: avoid reinventing wheels where unnecessary and position GenGraph clearly in that landscape.

Issue 14 — Explore JSON-LD / linked-data compatibility

Title: Explore JSON-LD / linked-data compatibility for GenGraph

Body:

GenGraph is currently “plain JSON”, but much of what it does overlaps with linked data / RDF ideas.

Questions:

Should we define an optional JSON-LD @context for GenGraph?

Could entities be easily mapped to IRIs for use in RDF stores?

How do we keep the spec usable by non-linked-data people while still being compatible?

Deliverable:

A short design note or prototype @context file for JSON-LD.

Recommendation on whether this should be part of v0.x or later.

Issue 15 — Titles and property modelling: minimal requirements

Title: Define minimal modelling for titles and properties (lost titles / land analysis)

Body:

One motivating use case for GenGraph is:

Tracking titles (noble, chivalric, offices)

Tracking properties (land, estates)

Exploring inheritance patterns, “lost titles”, property anomalies, etc.

We should clarify:

What fields are minimally necessary on Title and Property to support:

Historical research

Automated reasoning / rule engines

What belongs in GenGraph vs. what should be handled by external legal/logic layers

Output:

Updated sections in SPEC.md with clearer guidance and examples for Title and Property.
